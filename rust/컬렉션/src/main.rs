fn main() {
    // 컬렉션은, 다수의 값을 담을 수 있다는 특징이 있다.
    // 힙에 저장됨: 데이터의 양이 컴파일 타임에 결정되지 않아도 되며, 프로그램 실행중에 늘어나거나 줄어들 수 있다.
    벡터();
    문자열();
    해시맵();
}

fn 벡터() {
    // 여러 개의 값을 서로 붙어있게 저장할 수 있도록 해줌
    // 모든 값을 서로 이웃하도록 배치하는 단일 데이터 구조에, 하나 이상의 값(같은 타입만) 저장 가능.
    let _벡터: Vec<i32> = Vec::new(); // 비어있는 벡터
    let mut 숫자벡터 = vec![1, 2, 3]; // 타입이 Vec<i32>로 자동 추론. 기본 정수형이 i32이므로

    let mut 변경가능한벡터 = Vec::new();
    변경가능한벡터.push(5);
    변경가능한벡터.push(6);
    // 당연히 가변 변수(let mut)여야 함.

    let _세번째값 = &숫자벡터[2];
    let 있을지도_없을지도_모르는_세번째_값 = 숫자벡터.get(2); // get으로 접근하면 Option<&T>의 타입을 가짐, 기본적으로 없다면 None을 반환함

    match 있을지도_없을지도_모르는_세번째_값 {
        Some(있을지도_없을지도_모르는_세번째_값) => {
            println!(
                "세번째 값({:?})이 있습니다.",
                있을지도_없을지도_모르는_세번째_값
            )
        }
        None => println!("세번째 값이 없습니다."),
        // 없을 때의 동작을 설정하게 할 수 있도록 get으로도 인덱스에 접근할 수 있게 함.
    }

    let 첫번째값 = &숫자벡터[0];
    숫자벡터.push(6); // 새로운 메모리로 할당 및 기존 요소들을 이쪽으로 복사. 이 때 첫번째값은 이전 메모리를 가리키게 됨.
                      // println!("첫번째 값은: {}", 첫번째값);
                      // 윗 행을 지운다면 컴파일이된다. '첫번째값'을 프린트하는 순간 컴파일에 실패한다. 참조한 값을 쓰려고 할 때 문제가 발생하는 듯.

    // 벡터는 모든 요소가 서로 붙어서 메모리에 저장되는데, 이 상황에서 새로운 요소를 벡터 끝에 추가할 경우 메모리가 부족하면 새로운 메모리를 할당하고 이전 요소들을 새로운 메모리로 복사함.
    // 이 경우 기존 참조자는 해제된 메모리를 가리키게 되므로 참조자를 불러오려고 할 때, 대여 규칙으로 막아둔 것.

    for i in &숫자벡터 {
        println!("{}", i); // 불변 참조자를 얻어서, 이를 출력함.
    }
    for i in &mut 숫자벡터 {
        // 숫자벡터 내의 값을 변경한다는 전제가 있으려면, mutable하게 가져와야 하고
        // 변경하려면 `*`` 역참조 연산자로 i의 값을 얻어야 함.
        *i += 50;
    }
    println!("{:?}", 숫자벡터);

    // enum을 이용해서 여러 타입 저장하기
    enum 스프레드시트_값 {
        정수(i32),
        부동소수점(f64),
        텍스트(String),
        // 여기서 타입을 꼭 알아야 하는 이유는, 각 타입을 저장할 때 얼마만큼의 힙 메모리가 필요한지를 알아야 하기 때문이다.
        // 모든 타입의 집합을 알지 못하는 경우, 열거형을 사용할 수 없다.
    }

    let 행 = vec![
        스프레드시트_값::정수(3),
        스프레드시트_값::텍스트(String::from("텍스트")),
        스프레드시트_값::부동소수점(10.12),
    ];
    // 이렇게 하면, 벡터의 각 요소가 다른 타입일 수 있음.

    {
        let 스코프를_나가면_버려질_벡터 = vec![1, 2, 3];
        // ...
    } // 여기서 벡터는 버려짐
}

fn 문자열() {
    // 문자(character)의 모음.
}

fn 해시맵() {
    // 어떤 값을 특정한 키와 연관지어 주도록 해줌
}

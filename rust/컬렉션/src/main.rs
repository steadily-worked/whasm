fn main() {
    // 컬렉션은, 다수의 값을 담을 수 있다는 특징이 있다.
    // 데이터들이 힙에 저장됨: 데이터의 양이 컴파일 타임에 결정되지 않아도 되며, 프로그램 실행중에 늘어나거나 줄어들 수 있다.
    벡터();
    문자열();
    해시맵();
}

fn 벡터() {
    // 여러 개의 값을 서로 붙어있게 저장할 수 있도록 해줌
    // 모든 값을 서로 이웃하도록 배치하는 단일 데이터 구조에, 하나 이상의 값(같은 타입만) 저장 가능.
    let _벡터: Vec<i32> = Vec::new(); // 비어있는 벡터: 벡터 내 값이 없기 때문에 타입 추론이 되지 않으므로, 타입을 명시해야 함.
    let mut 숫자벡터 = vec![1, 2, 3]; // 타입이 Vec<i32>로 자동 추론. 기본 정수형이 i32이므로

    // 벡터 업데이트하기
    let mut 변경가능한벡터 = Vec::new();
    변경가능한벡터.push(5);
    // 당연히 가변 변수(let mut)여야 함. i32를 넣었으므로, 러스트는 '변경가능한벡터' 가 Vec<i32> 타입을 가짐을 추론할 수 있다.
    // 변경가능한벡터.push('d');

    // 벡터 요소 읽기: 인덱싱, `get` 메소드
    let _세번째값 = &숫자벡터[2];
    let 있을지도_없을지도_모르는_세번째_값 = 숫자벡터.get(2); // get으로 접근하면 match로 처리할 수 있는 Option<&T>의 타입을 가짐, 기본적으로 없다면 None을 반환함

    match 있을지도_없을지도_모르는_세번째_값 {
        Some(있을지도_없을지도_모르는_세번째_값) => {
            println!(
                "세번째 값({:?})이 있습니다.",
                있을지도_없을지도_모르는_세번째_값
            )
        }
        None => println!("세번째 값이 없습니다."),
        // 없을 때의 동작을 설정하게 할 수 있도록 인덱싱 외의 방법으로 get으로도 인덱스에 접근할 수 있게 함.
    }

    // let 첫번째값 = &숫자벡터[0];
    숫자벡터.push(6); // 새로운 메모리로 할당 및 기존 요소들을 이쪽으로 복사. 이 때 첫번째값은 이전 메모리를 가리키게 됨.
                      // println!("첫번째 값은: {}", 첫번째값);

    impl SampleStruct {
        fn add(&mut self) -> i32 {
            // self.a += 10;
            // 10
        }
    }
    struct SampleStruct {
        a: i32,
        b: i32,
    }

    let mut sample_struct = SampleStruct { a: 10, b: 20 };
    let 샘플 = &sample_struct.a; // 소유권을 가져갔기 때문에
                                 // sample_struct.add(); // sample_struct의 값의 변경을 수반할 수 있는 행위를 막는 것임(add 함수가 mutable self를 가진 이상 아무 일을 하지 않더라도).
    println!("{:?}", 샘플);

    // mutable reference와 그냥 reference가 동시에 빌려질 수 없다
    // 윗 행을 지운다면 컴파일이된다. '첫번째값'을 프린트하는 순간 컴파일에 실패한다. 참조자를 갖고 있는 상태에서 그게 사용될 수 있는 환경이 있다면 값의 변경이 불가능함.

    // 벡터는 모든 요소가 서로 붙어서 메모리에 저장되는데, 이 상황에서 새로운 요소를 벡터 끝에 추가할 경우 메모리가 부족하면 새로운 메모리를 할당하고 이전 요소들을 새로운 메모리로 복사함.
    // 이 경우 기존 참조자는 해제된 메모리를 가리키게 되므로 참조자를 불러오려고 할 때, 대여 규칙으로 막아둔 것.

    for i in &숫자벡터 {
        println!("{}", i); // 불변 참조자를 얻어서, 이를 출력함.
    }

    for i in &mut 숫자벡터 {
        // 숫자벡터 내의 값을 변경한다는 전제가 있으려면, mutable하게 가져와야 하고
        // 가변 참조자가 가리키는 값을 변경하려면 `*` 역참조 연산자로 i의 값을 얻어야 함.
        *i += 50;
    }

    println!("숫자벡터: {:?}", 숫자벡터);

    // enum을 이용해서 여러 타입 저장하기
    enum 스프레드시트_값 {
        정수(i32),
        부동소수점(f64),
        텍스트(String), // tuple-like variant
                        // 여기서 타입을 꼭 알아야 하는 이유는, 각 타입을 저장할 때 얼마만큼의 힙 메모리가 필요한지를 알아야 하기 때문이다.
                        // 모든 타입의 집합을 알지 못하는 경우, 열거형을 사용할 수 없다.
    }

    let 행 = vec![
        스프레드시트_값::정수(3),
        스프레드시트_값::텍스트(String::from("텍스트")),
        스프레드시트_값::부동소수점(10.12),
    ];
    // 이렇게 하면, 벡터의 각 요소가 다른 타입일 수 있음.
    // 그런데, 벡터는 같은 타입의 값만을 저장할 수 있다고 했었는데, 이렇게 해서 가능한거라면.. 이걸 허용한 이유가 있을 것 같은데, 잘 모르겠다.
    // variant는 variant고, type은 enum이 된다.

    {
        let _스코프를_나가면_버려질_벡터 = vec![1, 2, 3];
        // ...
    } // 여기서 벡터는 버려짐
}

fn 문자열() {
    // 문자(character)의 모음. 바이트의 콜렉션으로 구현되어있다.
    // 문자열 타입은 오직 문자열 슬라이스 `str` 타입 하나뿐이다. 일반적으로 가변 참조자인 `&str`의 형태로 사용된다.
    // String 타입은 언어의 핵심 기능에 구현된 게 아니라, 러스트의 표준 라이브러리를 통해 제공된다.
    // 커질 수 있고, 가변적이고, 소유권을 갖고 있고, UTF-8로 인코딩된 문자열 타입이다.

    let mut _문자열 = String::new(); // 비어있는 String 생성
    let _문자열55 = "";
    let 문자열2 = "디폴트 컨텐츠";
    let _초기_데이터가_있는_문자열 = 문자열2.to_string();
    let _초기_데이터가_있는_문자열2 = "디폴트 컨텐츠".to_string();
    let _초기_데이터가_있는_문자열3 = String::from("디폴트 컨텐츠");

    // 문자열 추가
    let mut 문자열3 = String::from("안녕하세요");
    let 문자열_슬라이스: &str = " 여러분";
    문자열3.push_str(문자열_슬라이스);
    // &str을 파라미터로 가짐. 파라미터의 소유권을 가져올 필요가 없기 때문.
    // -> 왜 가져올 필요가 없을까? 문자열 슬라이스가 참조자라서? -> &str은 선언하는 순간부터 어차피 불변이므로.
    문자열3.push('l'); // push는 char만 추가 가능.

    // 문자열 결합
    let 문자열4 = String::from("안녕하세요");
    let 문자열5 = String::from(" 여러분");
    let _결합된_문자열 = 문자열4 + &문자열5; // 문자열4의 소유권을 가져오지 않음. 문자열5의 소유권을 가져옴.
                                             // 왜 첫번째 요소는 다시 사용될 수 없을까?
                                             // fn add(self, s: &str) -> String { /* ... */ }
                                             // + 시그니처는 위의 add 함수를 사용하므로.
                                             // 근데, s는 &str인데, &String을 넣어도 되는 이유가 뭘까? -> &String이 &str로 강제될 수 있기 때문: 역참조 강제
                                             // 그리고, self가 &를 안갖고 있으므로 add 함수는 self의 소유권을 가져가게 된다.
    println!("{}", 문자열4); // 이렇게 하면, 문자열4는 사용할 수 없음. ('결합된_문자열'이 소유권을 가져갔기 때문)
                             // 결과적으로, let 결합된_문자열 = 문자열4 + &문자열5; 는
                             // 문자열4의 소유권을 가져다가 문자열5의 복사본을 추가한다음,
                             // 결과물의 소유권을 반환하는 것.
    let 문자열6 = String::from(" 반갑습니다.");
    let 결합된_문자열2 = format!("{문자열5} {문자열6}",);
    println!("결합된 문자열: {}", 결합된_문자열2);
    // format! 은 println! 처럼 작동하지만, 화면에 결과를 출력하는대신 결과가 담긴 String을 반환해준다.

    // 인덱싱
    // let 안 = 문자열4[0];
    // 이건 안됨. 문자열은 바이트의 콜렉션(Vec<u8>)으로 구현되어있기 때문에, 인덱싱을 하면 바이트를 반환함.
    // 이는 문자열이 UTF-8로 인코딩되어 있기 때문에, 각 글자가 1바이트가 아닐 수 있기 때문.
    // 따라서, 문자열을 인덱싱하려면, 문자열 슬라이스를 사용해야 함.
    let 안 = &문자열6[0..4]; // 이렇게 하면, 문자열 슬라이스를 반환함.
                             // 그러나, 이렇게 하면 런타임에러가 발생할 수 있음. 이유는, 문자열 슬라이스가 유효한지 검사하지 않기 때문.
                             //  따라서, get을 쓰는 게 제일 나아 보임(?)

    println!("{}", 안);

    // 문자열에 대한 반복
    for c in "안녕하세요".chars() {
        println!("{}", c); // 문자열의 각 문자를 출력함.
    }
}

fn 해시맵() {
    // 어떤 값을 특정한 키와 연관지어 주도록 해줌
    // key끼리와 값끼리는 모두 같은 타입이어야 함.

    use std::collections::HashMap; // 세가지 컬렉션중 제일 덜 사용되어서, use로 가져와야함.

    // HashMap::new()로 선언 후 insert하기
    let mut 해시맵 = HashMap::new();
    해시맵.insert(String::from("블루"), 10); // key-value의 형태
    해시맵.insert(String::from("레드"), 20);

    let 팀이름 = String::from("블루");
    let 점수 = 해시맵.get(&팀이름).copied().unwrap_or(0);
    // let 점수 = 해시맵.get(&팀이름).unwrap_or(&0);
    // 이렇게 해주면 안되나?
    println!("{:?}", 점수);
    println!("{}", 점수);
    // get 메소드는 Option<&V>를 반환함. copied()를 통해 Option<V>로 가져와서,
    // unwrap_or()을 통해 '점수'가 해당 키에 대한 아이템을 갖고 있지 않을 경우 점수에 0을 설정하도록 처리함.
    // 여기서, 왜 Option<V>를 가져오는지? -> get은 참조자를 반환하기 때문에, copied()를 통해 값을 복사해야 함.

    // for 루프를 통해 해시맵의 각 키와 값을 순회할 수 있음.
    for (팀이름, 점수) in &해시맵 {
        println!("{}: {}", 팀이름, 점수); // 순서 보장이 안됨
    }

    let 유효하지_않아질_이름 = String::from("색상");
    let 유효하지_않아질_색상 = String::from("노랑");

    let mut 색상_해시맵 = HashMap::new();
    색상_해시맵.insert(유효하지_않아질_이름, 유효하지_않아질_색상);
    // HashMap에 insert한 순간부터 이름과 색상은 유효하지 않게 됨(즉, 사용 불가).
    // println!("{}: {}", 유효하지_않아질_이름, 유효하지_않아질_색상);

    // 해시맵 업데이트하기

    // 1. 덮어쓰기
    해시맵.insert(String::from("블루"), 25);
    println!("{:?}", 해시맵);

    // 2. 키가 없을 때만 값 추가하기
    해시맵.entry(String::from("블루")).or_insert(50);
    해시맵.entry(String::from("노랑")).or_insert(50);
    println!("{:?}", 해시맵);

    // 3. 예전 값에 기초하여 값 업데이트하기
    let 샘플_텍스트 = "안녕 세상 좋은 세상";
    let mut 해시맵2 = HashMap::new();

    for 단어 in 샘플_텍스트.split_whitespace() {
        let 개수 = 해시맵2.entry(단어).or_insert(0);
        // '개수' 변수에 가변 참조자를 저장하고, 여기에 값을 할당하기 위해 '개수'를 역참조함.
        *개수 += 1;
    }
    println!("{:?}", 해시맵2);
    // "안녕", "세상", "좋은"의 출력 순서는 보장되지 않음.
}

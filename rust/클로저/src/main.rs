use std::{thread, time::Duration};

fn main() {
    클로저로_환경_캡처하기();
    클로저_타입_추론과_명시();
    참조자_캡처하거나_소유권_이동();
    새_스레드에서_벡터_호출();
    캡처된_값을_밖으로_이동하기와_fn_트레이트();
}

fn 클로저로_환경_캡처하기() {
    // 변수에 저장하거나 다른 함수에 인수로 전달할 수 있는 익명 함수.
    // 한 곳에서 클로저를 만들고 다른 컨텍스트의 다른 곳에서 이를 호출하여 평가할 수 있음.
    // 함수와 다르게 클로저는, 정의된 스코프에서 값을 캡처할 수 있음.

    // 무료 티셔츠 증정 프로모션. 좋아하는 색상을 설정해뒀다면 그 색상의 티셔츠를 받을 수 있음.
    // 설정해두지 않았다면 회사가 현재 제일 많이 갖고 있는 색상을 받게됨.

    #[derive(Debug, PartialEq, Copy, Clone)]
    enum 셔츠색상 {
        빨강,
        파랑,
    }

    struct 인벤토리 {
        셔츠: Vec<셔츠색상>,
    }

    impl 인벤토리 {
        fn 경품(&self, 유저선호: Option<셔츠색상>) -> 셔츠색상 {
            // 클로저.
            // Option<T>가 Some 배리언트라면 unwrap_or_else는 그 Some 안에 들어있는 값을 반환하고,
            // Option<T>가 None이라면 클로저를 호출하여 클로저가 반환한 값을 반환해준다.
            유저선호.unwrap_or_else(|| self.가장많은색상())
        }

        fn 가장많은색상(&self) -> 셔츠색상 {
            let mut 빨강 = 0;
            let mut 파랑 = 0;

            for 색상 in &self.셔츠 {
                match 색상 {
                    셔츠색상::빨강 => 빨강 += 1,
                    셔츠색상::파랑 => 파랑 += 1,
                }
            }
            if 빨강 > 파랑 {
                셔츠색상::빨강
            } else {
                셔츠색상::파랑
            }
        }
    }

    let 스토어 = 인벤토리 {
        셔츠: vec![셔츠색상::빨강, 셔츠색상::파랑, 셔츠색상::빨강],
    };

    let 유저선호1 = Some(셔츠색상::빨강);
    let 경품1 = 스토어.경품(유저선호1);
    println!(
        "{:?} 선호를 갖고있는 유저 1은 {:?}을 가졌다.",
        유저선호1, 경품1
    );

    let 유저선호2 = None;
    let 경품2 = 스토어.경품(유저선호2);
    println!(
        "{:?} 선호를 갖고있는 유저 2는 {:?}을 가졌다.",
        유저선호2, 경품2
    );
    // 빨강이 더 많으므로, 선호가 없는 유저는 빨강을 갖게됨.

    // Some(빨강) 선호를 갖고있는 유저 1은 빨강을 가졌다.
    // None 선호를 갖고있는 유저 2는 빨강을 가졌다.
}

fn 클로저_타입_추론과_명시() {
    // 클로저는 보통 fn 함수에서처럼 파라미터 혹은 리턴 값의 타입을 명시하도록 요구하지 않는다.
    // 함수의 타입 명시는 그 타입이 사용자들에게 노출되는 명시적인 인터페이스의 일부분이기 때문에 요구된다.
    // 그러나 클로저는 함수처럼 노출된 인터페이스로 사용되지 않는다: 클로저는 이름이 지어지거나 라이브러리의 사용자들에게 노출되지 않은 상태로 변수에 저장되고 사용된다.

    // 클로저는 통상적으로 짧고, 임의의 시나리오가 아니라 짧은 컨텍스트 내에서만 관련된다. 이러한 한정된 컨텍스트 내에서 컴파일러는 대부분의 변수에 대한 타입을 추론하는 방법과 비슷한 식으로 클로저의 파라미터와 리턴 타입을 추론한다.
    let 비싼_클로저 = |num: u32| -> u32 {
        println!("느리게 계산중...");
        thread::sleep(Duration::from_secs(2));
        num
    };
    // 타입 명시가 추가되면 클로저 문법이 함수 문법과 유사해보인다.
    // 여기서는 인수로 전달하는 위치에서 클로저를 정의하지않고 클로저를 정의하여 변수에 저장하고있다.

    fn 더하기_1_v1(x: u32) -> u32 {
        x + 1
    }
    let 더하기_1_v2 = |x: u32| -> u32 { x + 1 };
    let 더하기_1_v4 = |x: u32| x + 1; // 이 본문이 딱 하나의 표현식이므로, 중괄호를 제거해도 된다.

    let 예시_클로저 = |x| x; // 그냥 반환하는 클로저
    let s = 예시_클로저(String::from("hello")); // 이 때, 컴파일러는 클로저의 x 타입과 반환 타입이 String이라고 추론함 -> 이 String 타입이 예시_클로저에 고정됨.
    let n = 예시_클로저(5.to_string()); // 따라서, 5가 아니라 5.to_string()으로 변환되어야 함.
}

fn 참조자_캡처하거나_소유권_이동() {
    // 클로저는 세가지 방식으로 자신의 환경으로부터 값을 캡처할 수 있다.
    // 1. 불변으로 빌려오기
    // 2. 가변으로 빌려오기
    // 3. 소유권 이동
    // 클로저는 캡처된 값이 쓰이는 방식에 기초하여 캡처할 방법을 결정할 것이다.
    let 리스트 = vec![1, 2, 3];
    println!("원본 리스트: {:?}", 리스트);
    let 빌리기 = || println!("클로저에서: {:?}", 리스트);
    println!("클로저 호출 전 리스트: {:?}", 리스트);
    빌리기();
    println!("클로저 호출 후 리스트: {:?}", 리스트);
    // 이 예시는, 불변 참조자를 캡처하는 클로저인데, 이는 그저 값을 출력하기 위해 불변 참조자가 필요한 상태이기 때문.
    // 이 예시는, 어떤 변수가 클로저의 정의에 바인딩될 수 있고, 이 클로저는 나중에 마치 변수 이름이 함수 이름인 것처럼 변수 이름과 괄호를 사용하여 호출될 수 있음을 보여줌.
    // 리스트에 대한 불변 참조자를 여러 개를 동시에 가질 수 있기 때문에 리스트에는 클로저 정의 전이나 후 뿐만 아니라 클로저의 호출 전과 후에도 여전히 접근이 된다.

    let mut 리스트2 = vec![1, 2, 3];
    println!("클로저 정의 이전: {:?}", 리스트2);

    let mut 가변_빌리기 = || 리스트2.push(7);
    // println!("클로저 호출 전: {:?}", 리스트2); // immutable borrow occurs here
    가변_빌리기();
    println!("클로저 호출 후: {:?}", 리스트2);
    // 가변_빌리기가 정의된 시점에, 이 클로저가 리스트에 대한 가변 참조자를 캡처한다. 클로저가 호출된 이후로 다시 클로저를 사용하고 있지 않으므로 가변 대여가 그 시점에서 끝난다.
    // 클로저의 정의와 호출 사이에는 출력을 위한 불변 대여가 허용되지 않는다: 이는 가변 대여가 있을 때에는 다른 대여가 허용되지 않기 때문.
    // 클로저의 본문에서 사용하고 있는 값의 소유권이 필요하지 않더라도 클로저가 소유권을 갖도록 만들고 싶다면, 파라미터 리스트 전에 move 키워드를 사용하면 된다.
}

fn 새_스레드에서_벡터_호출() {
    let 리스트 = vec![1, 2, 3];
    println!("클로저 정의 전: {:?}", 리스트);

    thread::spawn(move || println!("스레드에서: {:?}", 리스트))
        .join()
        .unwrap();

    // 여기서는, 새 스레드를 생성하여 여기에 인수로 실행될 클로저를 제공한다. 클로저의 본문에서는 리스트를 출력한다.
    // 이 예제에서는 클로저 본문이 여전히 불변 참조자만 필요할지라도, 클로저 정의의 앞부분에 move 키워드를 집어넣어 "리스트"가 이동되어야함을 명시할 필요가 있다.
    // 새로운 스레드가 메인 스레드의 나머지 부분이 끝나기 전에 끝날 수도 있고, 혹은 메인 스레드가 먼저 끝이 날 수도 있는데, 만일 메인 스레드가 "리스트"의 소유권을 유지하고 있는데, 새 스레드가 끝나기 전에 끝나버려서 "리스트"를 제거한다면 새 스레드의 불변 참조자는 유효하지 않게 될 것이다.
    // 따라서 컴파일러는 "리스트"를 새 스레드에 제공될 클로저로 이동시켜, 참조자가 유효하도록 요구한다.
}

fn 캡처된_값을_밖으로_이동하기와_fn_트레이트() {
    #[derive(Debug)]
    struct 사각형 {
        너비: u32,
        높이: u32,
    }

    let mut 리스트 = [
        사각형 {
            너비: 30, 높이: 50
        },
        사각형 {
            너비: 10, 높이: 40
        },
        사각형 {
            너비: 60, 높이: 45
        },
    ];
    리스트.sort_by_key(|r| r.너비);
    println!("{:#?}", 리스트);

    // sort_by_key가 FnMut 클로저를 갖도록 정의된 이유는, 이 함수가 클로저를 여러번 호출하기 때문이다: 슬라이스 내 각 아이템마다 한번씩.
    // 클로저 "|r| r.너비" 는 자신의 환경으로부터 어떤 것도 캡처나 변형, 혹은 이동을 시키지 않으므로, 트레이트 바운드 요건을 충족한다.

    // 반면 아래는 FnOnce 트레이트로만 구현한 예시를 보여준다.
    let mut 리스트2 = [
        사각형 {
            너비: 30, 높이: 50
        },
        사각형 {
            너비: 10, 높이: 40
        },
        사각형 {
            너비: 60, 높이: 45
        },
    ];

    // let mut 정렬_횟수 = vec![];
    let mut 정렬_횟수 = 0;
    let 값 = String::from("키가 호출된 순으로.");

    리스트.sort_by_key(|r| {
        // 정렬_횟수.push(값);
        정렬_횟수 += 1;
        r.너비
    });
    // println!("{:#?}", 리스트2);
    println!("{:#?}, {정렬_횟수} 횟수만큼 정렬되었음", 리스트2);

    // sort_by_key가 클로저를 호출하는 횟수를 세려고 시도하는, 부자연스럽고 난해한 방식이다.
    // 이 코드는, 클로저 환경의 String인 "값"을 "정렬_횟수" 벡터로 밀어넣는 형태로 횟수세기를 시도하고있다.
    // 클로저는 "값"을 캡처한다음 "값"의 소유권을 "정렬_횟수" 벡터로 보내서, "값"을 클로저 밖으로 이동시킨다. 이 클로저는 한 번만 호출될 수 있다:
    // 두번째 시도에서는 "값"이 더이상 이환경에 남아있지 않은데 "정렬_횟수" 벡터로 밀어넣으려고 하므로 동작하지 않을것이다.
    // 따라서, 이 클로저는 오직 FnOnce 만 구현하고있다.
    // 컴파일을 시도하면, 클로저가 FnMut를 구현해야 하기 때문에 "값"이 클로저 밖으로 이동될 수 없음을 지적하는 에러를 얻게된다.
    // 이를 고치기 위해서는, 클로저 본문을 수정하여 환경에서 "값"을 이동시키지 않도록 할 필요가 있다.
    // sort_by_key가 호출되는 횟수를 세기 위해서는, 환경 쪽에 카운터를 유지하면서 클로저 본문에서 이 값을 증가시키는 것이 더 직관적으로 계산하는 방법일 것이다.
}

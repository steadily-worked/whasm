// 라이프타임은 이미 사용해본 적 있는 또 다른 종류의 제네릭이다.
// 어떤 타입이 원하는 동작이 구현되어 있음을 보장하기 위한 것 (X) 어떤 참조자가 필요한 기간동안 유효함을 보장(O)
// 러스트에서 런타임에 사용되는 실제 참조자가, 반드시 유효할 것임을 보장하려면 제네릭 라이프타임 파라미터로 관계를 명시해야 한다.

fn main() {
    // 라이프타임으로_댕글링_참조_방지하기();
    // 대여_검사기();
    함수에서의_제네릭_라이프타임();
    라이프타임_명시_문법();
    함수_시그니처에서_라이프타임_명시하기();
    라이프타임의_측면에서_생각하기();
    구조체_정의에서_라이프타임_명시하기();
    라이프타임_생략();
    메서드_정의에서_라이프타임_명시하기();
    정적_라이프타임();
}

fn 라이프타임으로_댕글링_참조_방지하기() {
    // 라이프타임의 주 목적은 댕글링 참조 방지이다. 댕글링 참조란, 프로그램이 참조하려고 한 데이터가 아닌 엉뚱한 데이터를 참조하게 되는 원인이다.
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
    // 바깥쪽 스코프에서 r 변수를 초깃값 없이 선언하고 안쪽 스코프에서는 x 변수를 초깃값 5로 선언. 안쪽 스코프에서는 r 값에 x 참조자 대입. but 스코프를 벗어나는 시점에 x가 사라지므로 에러 발생
    // (r이 참조하는 값이 사용하려는 시점에 이미 자신의 스코프를 벗어남)
    // error[E0597]: `x` does not live long enough: 변수 x가 충분히 오래 살지 못했다.
    // 러스트가 이 코드가 유효한지 검사하는 방법?: "대여 검사기(borrow checker)"
}

fn 대여_검사기() {
    let r; // r의 라이프타임('a) 시작 (끝까지 유효))
    {
        let x = 5; // x의 라이프타임('b) 시작
        r = &x; // x의 라이프타임('b) 종료
    }
    println!("r: {}", r);
    // 러스트가 이렇게, 컴파일 타임에 두 라이프타임의 크기를 비교하고 'a 라이프타임을 갖는 r이 'b 라이프타임을 갖는 메모리를 참조하고 있음을 인지함.
    // 그러나, 'b가 'a보다 짧으므로(즉 더 오래 살지 못하므로) 컴파일러가 이 프로그램을 컴파일하지 않음.

    let x = 5;
    let r = &x;
    println!("r: {}", r); // r: 5. 이제 'b(x의 라이프타임)는 'a(r의 라이프타임)보다 더 길다.
                          // 러스트는, 참조자 r이 유효한 동안에는 x도 유효하다는 것을 알고 있으므로, r은 x를 참조할 수 있다.
}

fn 함수에서의_제네릭_라이프타임() {
    // 두 문자열 중 더 긴 것을 반환하는 함수
    fn 가장_긴_문자열(x: &str, y: &str) -> &str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    // 에러 발생. 리턴 타입에 제네릭 라이프타임 파라미터가 필요하다는 내용. 반환할 참조자가 x인지 y인지 러스트가 모르가 때문. -> 상황에 따라 x가 될수도, y가 될수도 있으니까.
    // 또한, 전달받은 참조자의 구체적인 라이프타임도 알 수 없다. 따라서, 참조자 간의 관계를 제네릭 라이프타임 파라미터로 정의하여 대여 검사기가 분석할 수 있도록 해야한다.

    let 문자열1 = String::from("abcd");
    let 문자열2 = "xyz";
    let 결과 = 가장_긴_문자열(문자열1.as_str(), 문자열2);
    println!("가장 긴 문자열: {}", 결과);
}

fn 라이프타임_명시_문법() {
    // 라이프타임을 명시한다고 해서, 참조자의 수명이 바뀌진 않는다. 그보다는, 여러 참조자에 대한 수명에 영향을 주지 않으면서 서로간 수명의 관계가 어떻게 되는지에 대해 기술하는 것.
    // 함수에 제네릭 라이프타임 파라미터를 명시하면, 어떤 라이프타임을 갖는 참조자라도 전달할 수 있다.
    // &i32 // 참조자
    // &'a i32 // 명시적인 'a 라이프타임을 갖는 참조자
    // &'a mut i32 // 명시적인 'a 라이프타임을 갖는 가변 참조자
}

fn 함수_시그니처에서_라이프타임_명시하기() {
    // 라이프타임 파라미터는 함수 시그니처의 일부로, 함수 이름과 파라미터 목록 사이에 <'a>를 추가하여 선언한다.
    // 함수 시그니처에서 라이프타임을 명시하면, 함수 정의 내에서 라이프타임을 사용할 수 있다.
    // 라이프타임 파라미터는 여러 개를 가질 수 있으며, 각 라이프타임 파라미터는 함수 시그니처 내에서 고유한 이름을 가져야 한다.
    // 라이프타임 파라미터는 함수 시그니처 내에서 사용되는 모든 참조자에 대해 적용된다.
    fn 가장_긴_문자열<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    let 문자열1 = String::from("abcd"); // 'a 라이프타임 시작

    {
        let 문자열2 = "xyz"; // 'b 라이프타임 시작
        let 결과 = 가장_긴_문자열(문자열1.as_str(), 문자열2);
        println!("가장 긴 문자열: {}", 결과); // 가장 긴 문자열: abcd
    } // 'b 라이프타임 끝. 그러니, 위 행의 프린트를 찍는 데는 문제가 없다.

    {
        let 문자열1 = String::from("이거는 긴 문자열임.");
        let 결과;
        {
            let 문자열2 = String::from("xyz");
            결과 = 가장_긴_문자열(문자열1.as_str(), 문자열2.as_str());
        } // 여기에서 결과가 유효하려면, '문자열2'가 바깥쪽 스코프(94행~)가 끝나기 전까지 유효해야 한다.
        println!("가장 긴 문자열은: {}", 결과);
        // 보기에는 문제가 없어보일 수 있다. 문자열1이 문자열2보다 기니까 결과는 문자열1을 참조하고, 프린트를 찍는 시점에서 문자열1이 유효하기 때문에.
        // 그렇지만, 러스트가 전달받은 것은 "가장_긴_문자열 함수가 반환할 참조자의 라이프타임은 파라미터의 라이프타임 중 작은 것과 동일하다"는 내용이었으므로,
        // 대여 검사기는 이 코드가 잠재적으로 유효하지 않은 참조자를 가질 수도 있다고 판단한다.
    }
}

fn 라이프타임의_측면에서_생각하기() {
    // 라이프타임 파라미터 명시의 필요성은, 함수가 어떻게 동작하는지에 따라서 달라진다.
    fn 가장_긴_문자열<'a>(x: &'a str, y: &str) -> &'a str {
        x
    }
    // 이렇게 무조건 첫번째 파라미터를 반환하도록 바꿨다고 가정해보면, y 파라미터에는 라이프타임을 지정할 필요가없다.
    // 참조자를 반환하는 함수를 작성할 때는 리턴 타입의 라이프타임 파라미터가 함수 파라미터중 하나와 일치해야 한다. 다음과 같이 가장_긴_문자열을 구현하면 컴파일할 수 없다.
    fn 가장_긴_문자열_2<'a>(x: &str, y: &str) -> &'a str {
        let 결과 = String::from("매우 긴 문자열");
        결과.as_str()
    }
    // 리턴 타입에 'a를 지정했지만 리턴값의 라이프타임이 그 어떤 파라미터와도 관련이 없으므로 컴파일할 수가 없다.
    // '결과'는 '가장_긴_문자열_2' 함수가 끝나면서 스코프를 벗어나 정리되는데, 함수에서 '결과'의 참조자를 반환하려고 하므로 문제가 발생한다.
    // 이런 상황을 해결하는 가장 좋은 방법은, 참조자 대신 값의 소유권을 갖는 데이터타입을 반환하여 함수를 호출한 함수 측에서 값을 정리하도록 하는 것이다.

    // 라이프타임 문법의 근본적 역할은, 함수의 다양한 파라미터와 반환 값의 라이프타임을 연결하는 데에 있다.
    // 한번 라이프타임을 연결해주고 나면, 러스트는 해당 정보를 이용해 댕글링 포인터 생성을 방지하고, 메모리 안전 규칙을 위배하는 연산을 배제한다.
}

fn 구조체_정의에서_라이프타임_명시하기() {
    // 지금까지 본 struct들은 모두 소유권이 있는 타입을 들고있었다.
    struct 중요_발췌<'a> {
        // 구조체에서도, 제네릭 라이프타임 파라미터의 이름을 구조체 이름 뒤 꺾쇠괄호 내에 선언하고 본문에서 라이프타임 파라미터를 이용한다.
        부분: &'a str,
        // 라이프타임 명시는, '중요_발췌 인스턴스는 '부분' 필드가 보관하는 참조자의 라이프타임보다 오래 살 수 없다는 의미이다.
    }

    let 소설 = String::from("이것은 소설입니다. 옛날 옛적에...");
    let 첫번째_문장 = 소설.split('.').next().expect("'a'를 찾을 수 없습니다.");
    let _i = 중요_발췌 {
        부분: 첫번째_문장
    };
    // 여기서 '소설' 데이터는, '중요_발췌' 인스턴스가 생성되기 전부터 존재하며 '중요_발췌' 인스턴스가 스코프를 벗어나기 전에는 소설이 스코프를 벗어나지 않으므로
    // '중요_발췌' 인스턴스는 유효하다.
}

fn 라이프타임_생략() {
    // 모든 참조자는 라이프타임을 가진다고 배웠고, 참조자를 사용하는 함수나 struct는 라이프타임 파라미터를 명시해야 한다고 배웠지만,
    fn first_word(s: &str) -> &str {
        let bytes = s.as_bytes();

        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {
                return &s[0..i];
            }
        }

        &s[..]
    }
    // 위 함수는 라이프타임 명시가 없었는데도 컴파일할 수 있었다. 이는 예측 가능한 상황들에 대해 러스트가 라이프타임을 추론할 수 있기 때문이다.
    // but, 완전한 추론 기능을 제공하는 것은 아니라서 러스트가 이 규칙(라이프타임 생략 규칙, lifetime elision rules)을 적용했음에도 라이프타임이 모호한 참조자가 있다면 컴파일러가 이 참조자의 라이프타임을 추측하지 않는다.

    // 함수 및 메소드 파라미터의 라이프타임은: 입력 라이프타임(input lifetime)이라 하며,
    // 리턴 값의 라이프타임은: 출력 라이프타임(output lifetime)이라 한다.
    // 라이프타임 명시가 없을 때 아래 세 가지 규칙을 사용하여 라이프타임을 알아내고자 한다.

    // 1. 컴파일러가 참조자인 파라미터 각각에게 라이프타임 파라미터를 할당한다.
    fn foo<'a>(x: &'a i32) {} // 파라미터가 하나인 함수는, 하나의 라이프타임 파라미터를 갖고
    fn bar<'a, 'b>(x: &'a i32, y: &'b i32) {} // 파라미터가 둘인 함수는, 두개의 라이프타임 파라미터를 갖는다.

    // 2. 만약 입력 라이프타임 파라미터가 딱 하나라면, 해당 라이프타임이 모든 출력 라이프타임에 대입된다.
    fn foo_2<'a>(x: &'a i32) -> &'a i32 {} // 이처럼 말이다.

    // 3. 입력 라이프타임 파라미터가 여러개인데, 그중 하나가 &self나 &mut self라면(즉 메소드라면) self의 라이프타임이 모든 출력 라이프타임에 대입된다.
    {
        fn 첫번째_단어(문장: &str) -> &str {}
        // 첫번째 규칙을 적용하면
        fn 첫번째_단어_첫번째_규칙_적용<'a>(문장: &'a str) -> &str {}
        // 입력 라이프타임이 하나밖에 없으므로 두번째 규칙을 적용한다.
        fn 첫번째_단어_두번째_규칙_적용<'a>(문장: &'a str) -> &'a str {}
        // 이제 시그니처의 모든 참조자가 라이프타임을 갖게 되었으므로 컴파일러는 프로그래머에게 이 함수의 라이프타임 명시를 요구하지 않고도 코드를 분석할 수 있다.
    }
    {
        fn 가장_긴_문자열(x: &str, y: &str) -> &str {}
        // 첫번째 규칙을 적용해 각 파라미터의 라이프타임을 지정한다.
        fn 가장_긴_문자열_첫번째_규칙_적용<'a, 'b>(x: &'a str, y: &'b str) -> &str {}
        // 입력 라이프타임이 하나가 아니므로 두번째 규칙은 적용하지 않음. '가장_긴_문자열_첫번째_규칙_적용' 함수가 메소드가 아니므로, 세번째 규칙도 적용할 수 없음.
        // 따라서, 러스트는 이 함수의 라이프타임을 추론할 수 없다.
    }
}

fn 메서드_정의에서_라이프타임_명시하기() {
    struct 중요_발췌<'a> {
        부분: &'a str,
    }

    impl<'a> 중요_발췌<'a> {
        fn 수준(&self) -> i32 {
            // "수준" 메소드의 파라미터는 &self 하나 뿐이며, 반환값은 참조자가 아닌 그냥 i32값이다.
            // impl 뒤에서 라이프타임 파라미터를 선언하여 타입명 뒤에서 사용하는 과정은 필수적이지만, 첫번째 생략규칙으로 인해 self 참조자의 라이프타임을 명시할 필요가 없다.
            3
        }

        fn 발표_후_반환(&self, 발표: &str) -> &str {
            println!("집중해 주세요: {}", 발표);
            self.부분
        }
        // 두개의 라이프타임이 있으므로 첫번째 생략규칙대로 &self와 "발표"의 라이프타임을 각각 할당한다.
        // 그 이후, 파라미터 중 하나가 &self이므로 세번째 규칙에 따라 &self의 라이프타임을 반환값에 대입한다.
        // 이제 모든 라이프타임이 추론되었다.
    }
}

fn 정적_라이프타임() {
    // 정적 라이프타임: 'static.
    // 해당 참조자가 프로그램의 전체 생애주기동안 살아있음을 의미한다. 모든 문자열 리터럴은 'static 라이프타임을 가지며, 다음과같이 명시할 수 있다.
    let s: &'static str = "난 정적 라이프타임을 갖고있어.";
    // 이 문자열의 텍스트는, 프로그램의 바이너리 내에 직접 저장되므로 언제나 이용할 수 있다. 따라서, 모든 문자열 리터럴의 라이프타임은 'static이다.
    // 'static을 사용하라는 제안이 담긴 에러메시지를 보게될 수도 있으나, 어떤 참조자를 'static으로 지정하기 전에 이게 반드시 전체 라이프타임동안 유지되어야하는 참조자인지,
    // 그리고 그게 진정 원하는 것인지 고민해봐야한다.
    // 보통은 'static을 사용하라는 제안이 댕글링 참조를 만들다가 발생하거나, 사용 가능한 라이프타임이 잘못 짝지어져서 발생하는데 이 경우 그 문제를 고치는 게 해결책이지, 'static을 사용하는 게 해결책이 아니다.
}

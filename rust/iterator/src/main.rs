use std::{env, process};

use iterator::Config;

fn main() {
    반복자로_일련의_아이템들_처리하기();
    iterator_트레이트와_next_메소드();
    다른_반복자를_생성하는_메소드();
    환경을_캡처하는_클로저_사용하기();
    커맨드라인_프로젝트_개선();
    반복자_어댑터로_더_간결한_코드_만들기();
    루프와_반복자_중_선택하기();
}

fn 반복자로_일련의_아이템들_처리하기() {
    let 벡터1 = vec![1, 2, 3];
    let 벡터1_반복자 = 벡터1.iter(); // 반복자 생성
                                     // println!({:?}, 벡터1_반복자); // 이 자체로 출력하는 건 안되나보다.
    for 값 in 벡터1_반복자 {
        println!("이 값을 가진다: {}", 값);
    }
    // for 루프를 사용할 때는 "벡터1_반복자"를 가변으로 만들 필요가 없는데, 루프가 "벡터1_반복자"의 소유권을 갖고 내부적으로 가변으로 만들기 때문이다.
}

fn iterator_트레이트와_next_메소드() {
    pub trait Iterator {
        type Item;
        fn next(&mut self) -> Option<Self::Item>;
        // 메소드 생략
    }
    // type Item, Self::Item은 이 Iterator 트레이트에 대한 연관 타입(associated type)이다.
    // Item 타입은, 반복자로부터 반환되는 타입이 된다는 것임.
    // next 메소드: Some으로 감싼 반복자의 아이템을 하나씩 반환하고, 반복자가 종료될 때 None을 반환함.
}

fn 다른_반복자를_생성하는_메소드() {
    // 반복자 어댑터는 Iterator 트레이트에 정의된 메소드로 반복자를 소비하지 않는다. 대신 원본 반복자의 어떤 측면을 바꿔서, 다른 반복자를 제공한다.
    let 벡터1 = vec![1, 2, 3];
    // 벡터1.iter().map(|x| x + 1); // map 메소드는 클로저를 인자로 받아서, 클로저가 반환하는 값을 가지는 새로운 반복자를 생성한다.
    // unused `Map` that must be used. iterators are lazy and do nothing unless consumed
    //  위의 코드는 아무 일도 하지 않는다; 넘겨진 클로저는 호출되지 않는다. 반복자 어댑터가 게으르고, 반복자를 여기서 사용할 필요가 있다고 한다.

    let 벡터2: Vec<_> = 벡터1.iter().map(|x| x + 1).collect(); // collect 메소드는 반복자를 소비하고, 그 결과를 새로운 컬렉션으로 만든다.
    assert_eq!(벡터2, vec![2, 3, 4]);

    // map이 클로저를 인수로 받기 때문에, 각 아이템에 대해 수행하고자 하는 어떤 연산이라도 지정할 수 있다.
    // 이 예시는, Iterator 트레이트가 제공하는 반복 동작을 재사용하면서 클로저로 동작의 일부를 커스터마이징할 수 있게 해주는 방법을 보여주는 예시이다.
    // 반복자 어댑터의 호출을 연결시킬 경우, 복잡한 동작을 읽기 쉬운 방식으로 수행할 수 있다.
    // 하지만 모든 반복자는 게으르므로, 반복자 어댑터를 호출한 결과를 얻기 위해서는 소비 어댑터 중 하나를 호출해야만 한다.
}

fn 환경을_캡처하는_클로저_사용하기() {
    // 많은 반복자 어댑터는, 클로저를 인수로 사용하고, 보통 반복자 어댑터의 인수에 명시되는 클로저는 자신의 환경을 캡처하는 클로저일 것이다.
    // 예시로, 클로저 인수를 사용하는 filter 메소드를 사용해보자. 이 클로저는 아이템을 받아서 bool을 반환한다. 클로저가 true를 반환하면,
    // 그 값을 filter에 의해 생성된 반복자에 포함시키게 된다. 클로저가 false를 반환할 경우 포함시키지 않는다.
}

fn 커맨드라인_프로젝트_개선() {
    let args: Vec<String> = env::args().collect();

    // let config = Config::build(&args).unwrap_or_else(|err| {
    //     eprintln!("파싱 인자 에러: {}", err);
    //     std::process::exit(1);
    // });
    // 위 함수를 이제 아래의 형태로 바꿀 수 있다. env::args의 반환값을 Config::build로 넘기기.
    let config = Config::build_after_iterator(env::args()).unwrap_or_else(|err| {
        eprintln!("파싱 인자 에러: {}", err);
        process::exit(1);
    });
    // env::args() 는 반복자를 반환한다. 반복자의 값들을 벡터로모아서 Config::build에 슬라이스를 넘기는 대신 이번에는 env::args로부터 반환된
    // 반복자의 소유권을 직접 Config::build로 넘기고 있따.
}

fn 반복자_어댑터로_더_간결한_코드_만들기() {
    // lib.rs 참고
}

fn 루프와_반복자_중_선택하기() {
    // 대부분의 러스트 프로그래머는 반복자 스타일을 선호한다. 처음에 사용하긴 다소 어렵지만 다양한 반복자 어댑터와 어떤 일을 하는지에 대해 감을 잡으면
    // 반복자들을 이해하기 쉬워질 것이다.
    // 이는 몇몇 아주 흔한 코드를 추상화해서 제거하므로 반복자의 각 요소가 반드시 통과해야 하는 필터링 조건과 같이 이 코드에 유일한 개념을 더 알기 쉽게 한다.
}

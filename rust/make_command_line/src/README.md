## grep을 직접 구현한 버전(커맨드라인 프로그램) 만들기

여기서 grep이란, Globally search a Regular Expression and Print의 약자로, 고전적인 커맨드라인 검색도구이다.

가장 단순한 사용례에서, grep은 어떤 특정한 파일에서 특정한 문자열을 검색하고,
이를 위해 grep은 파일 경로와 문자열을 인수로 받는다.
그다음 파일을 읽고, 그 파일 중 문자열 인수를 포함하고 있는 라인을 찾고, 그 라인들을 출력한다.

1. 환경 변수의 값을 읽어서 사용자가 커맨드 라인 도구의 동작을 설정하도록 한다.
2. 표준 출력 콘솔 스트림(stdout) 대신 표준 에러 콘솔 스트림(stderr)에 에러 메시지를 출력하여,
   예를들어 사용자가 화면을 통해 여러 메시지를 보는 동안에도 성공적인 출력을 파일로 리디렉션할 수 있게끔 할 것.

이 grep 프로젝트는 아래의 개념을 조합할 것이다.

1. 코드 조직화하기(7장),
2. 벡터와 문자열 사용하기(8장 컬렉션)),
3. 에러 처리하기(9장),
4. 적절한 곳에 라이프타임 사용하기(10장),
5. 테스트 작성하기(11장).

## 파일 읽기

`cargo run -- the poem.txt` 로 실행하면, 해당 파일의 내용이 `With text:` 와 함께 출력된다.

```text
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
```

하지만, 이 코드에는 몇가지 결점이 있다:

1.  현재 main 함수에 여러가지 기능이 있다 -> 일반적으로 함수 하나당 단 하나의 아이디어에 대한 기능을 구현할 때 함수가 더 명료해지고 관리하기 쉬워진다.
2.  처리 가능한 수준의 에러 처리를 하지 않고 있다. -> 프로그램은 아직 작고 따라서 이러한 결점이 큰 문제는 아니지만, 프로그램이 커지면 이 문제들을 깔끔하게 고치기 어려워진다.
    적은 양의 코드를 리팩토링하는 것이 훨씬 쉬우므로, 프로그램을 개발할 때 일찍 리팩토링하는 것은 좋은 관행이다

## 모듈성과 에러 처리 향상을 위한 리팩토링

현재 4가지 문제를 고치려고 한다:
(`인수-받고-저장하고-파일-읽기` 함수를 main으로 간주)

1. main 함수가 지금 두가지 일을 수행하고 있다: 인수 파싱, 파일 읽기.
   - 프로그램이 커짐에 따라 main 함수에서 처리하는 개별 작업의 개수는 증가할 것이다.
     함수의 책임 소재가 점점 커지면 기능 추론이 어려워지고 테스트도 어려워지고 기존 기능을 깨뜨리지 않으면서 새 기능을 추가하기도 어려워진다.
2. `query`와 `file_path`가 프로그램의 설정 변수지만, `contents` 같은 변수는 프로그램 로직을 수행하기 위해 사용된다.
   - main이 점점 길어질수록 필요한 변수들이 더 많이 스코프에 있게되고, 이는 프로그램의 복잡성을 증가시킨다. 설정 변수들을 하나의 구조체로 묶어서 목적을 분명히 하는 것이 좋다.
3. 파일 읽기 실패 시, 에러 메시지 출력을 `expect`를 통해서 했는데 이 메시지가 겨우 `Should have been able to read the file` 밖에 출력하지 못한다는 것이다.
   - 에러 메시지는 파일을 못 찾았거나, 파일을 열 권한이 없다든가 하는 다양한 이유로 발생할 수 있다. 모든 에러에 대해 동일한 에러 메시지를 출력하고 있다. 이는 사용자에게 어떠한 정보도 제공할 수 없다.
4. expect가 서로 다른 에러를 처리하기 위해 반복적으로 사용되는데, 만일 사용자가 실행되기 충분한 인수를 지정하지 않고 프로그램을 실행한다면 사용자는 러스트의 `index out of bounds` 에러를 얻게 될 것이다. 그리고 이 에러는, 문제를 명확하게 설명하지 못한다.
   - 모든 에러 처리 코드가 한 곳에 있어서 미래에 코드를 유지보수할 사람이 에러 처리 로직을 변경하기를 원하는 경우, 찾아봐야 하는 코드가 한 군데에만 있는 것이 가장 좋을 것이다.
   - 모든 에러 처리 코드를 한 곳에 모아두면 최종 사용자에게 의미 있는 메시지를 출력할 수 있다.

## 바이너리 프로젝트에 대한 관심사 분리

여러 작업에 대한 책임을 main에 떠넘기는 조직화 문제는 바이너리 프로젝트에서 흔한 일이다.
이에 따라 러스트 커뮤니티에서는 관심사를 나누기 위한 가이드라인을 개발했다.

- 프로그램을 `main.rs`와 `lib.rs`로 분리하고, 프로그램 로직을 `lib.rs`에 남긴다.
- 커맨드 라인 파싱 로직의 크기가 작은 동안에는 `main.rs`에 남을 수 있다.
- 커맨드 라인 파싱 로직이 복잡해지기 시작하면, `main.rs`로부터 추출하여 `lib.rs`로 옮긴다.

이 과정을 거친 후 `main` 함수에 남아있는 책임소재는 다음으로 한정되어야 한다:

- 인수 값을 갖고 커맨드 라인 파싱 로직 추출하기
- 그 밖의 설정
- lib.rs의 `run` 함수 호출
- `run`이 에러를 반환할 때 에러 처리하기

이 패턴은 관심사 분리에 관한 것이다: `main.rs`는 프로그램의 실행을 다루고 `lib.rs`는 당면한 작업의 모든 로직을 처리한다.
`main` 함수를 직접 테스트할 수 없으므로,이 구조는 `lib.rs` 내의 함수 형태로 테스트를 옮기게 하여 여러분의 모든 프로그램 로직을 테스트하게끔 한다. `main.rs`에 남겨진 코드는 정확한지 검증할 때 읽는 것만으로도 충분할 정도로 작아질 것이다.

// 모듈로 관련된 코드 묶기
// `mod` 키워드와 모듈 이름을 지정하여 모듈을 정의함
mod back_of_house;
mod front_of_house;
use crate::back_of_house::지원부서;
use crate::front_of_house::접객부서;

pub fn 레스토랑에서_식사하기() {
    // 절대 경로: create로 시작함
    crate::접객부서::호스팅::대기하기();

    // 상대 경로: 모듈 이름으로 시작함
    접객부서::호스팅::대기하기();

    // 둘중에 뭘 선택할지는, 상황에 따라 결정하면 됨.
    // ex) 접객부서 모듈을 다른 모듈 내부로 옮겼을 때, 절대 경로인 경우 수정해야함
    // ex2) 레스토링에서_식하가이 함수를 서빙 모듈 내부로 옮겼을 경우, 상대 경로인 경우 수정해야함.

    // 러스트에서 모든 아이템은 부모 모듈에 대해 기본적으로 비공개이기 때문에(왜?),
    // 호스팅 모듈에 대해 pub 키워드를 붙이지 않으면 컴파일에 실패한다.
    // 호스팅을 pub로 바꾸더라도, 호스팅 모듈 내용은 여전히 비공개기 때문에, 내부 함수에 대해서도 똑같이 pub 처리를 해줘야한다.

    // 여기서, '접객부서'에 pub가 붙지 않아도 되는 이유는, 레스토랑에서_식사하기 함수와 접객부서 모듈이 같은 파일에 있기 때문
    // (즉, 같은 모듈 내에 정의되어 있는 형제 관계이기 때문)이다.

    // 구조체
    let mut 식사 = 지원부서::아침식사::여름("호밀 토스트");
    식사.토스트 = String::from("밀 토스트"); // 먹고싶은 식사 바꾸기
    println!("토스트는 이걸 먹을래요: {}", 식사.토스트);
    // 식사.제철과일 = String::from("딸기"); // 과일은 조회, 수정 불가능. private이므로.

    // 열거형
    let 주문1 = 지원부서::에피타이저::수프;
    let 주문2 = 지원부서::에피타이저::샐러드;
}

// crate
//  └── front_of_house
//      ├── hosting
//      │   ├── add_to_waitlist
//      │   └── seat_at_table
//      └── serving
//          ├── take_order
//          ├── serve_order
//          └── take_payment

// 경로를 사용하여 모듈 트리의 아이템 창조하기

use crate::접객부서::호스팅;
// use 키워드를 통해, 모듈을 스코프 안으로 가져올 수 있다
// use crate::접객부서::호스팅::대기하기; 로 함수를 호출할 수도 있지만. 일반적이지 않다.
// 이렇게 되면, 호출할 때 '대기하기()' 만 가져오므로, 사용 시점에 '대기하기()'가 어떤 모듈의 함수인지 알기 어려워진다.

// 여기서 use 대신 pub use를 쓴다면, 스코프로 가져옴과 동시에 다른 곳에서 해당 아이템을 가져갈 수 있도록 만들게 됨.

pub fn _레스토랑에서_식사하기() {
    호스팅::대기하기(); // private이므로, 접근 불가
}

// mod 소비자 {
//     // 이렇게, 모듈 내부에서 불러오려고 하는 경우 `use` 구문과 다른 스코프가 되기때문에 컴파일 불가능함.
//     pub fn 레스토랑에서_식사하기() {
//         호스팅::의자에앉기();
//     }
// }

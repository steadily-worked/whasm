## 스마트 포인터

- 포인터(pointer)란, 메모리의 주소값을 담고있는 변수에 대한 일반적인 개념. 이 주소값은 어떤 다른 데이터를 참조함(가리킴). Rust의 가장 흔한 예시는 참조자(`&`)이다.
- but, 스마트 포인터(smart pointer)는 포인터처럼 작동하며 추가적인 메타데이터와 능력들도 갖고 있는 데이터 구조임.
  - 참조 카운팅(reference counting) 스마트 포인터 타입: 소유자의 개수를 추적. 더이상 소유자가 없으면 데이터를 정리.
  - 참조자는 데이터를 빌리기만 하지만, 스마트 포인터는 대부분 가리킨 데이터를 소유함
  - 예시: `String`, `Vec<T>`.
- 스마트 포인터는 구조체를 이용해 구현돼있는데, 다른 구조체들과 달리 `Deref`와 `Drop` trait을 구현함
  - `Deref`: 스마트 포인터 구조체의 인스턴스가 참조자처럼 동작하도록 하여 참조자 혹은 스마트 포인터와 함께 작동하는 코드를 작성할 수 있도록 해줌
  - `Drop`: 스마트 포인터의 인스턴스가 스코프 밖으로 벗어났을 때 실행되는 코드를 커스터마이징 가능해도록 해줌
- 배워볼 것
  - 값을 힙에 할당하기 위한 `Box<T>`
  - 복수 소유권을 가능하게 하는 참조 카운팅 타입인 `Rc<T>`
  - 대여 규칙을 컴파일 타임 대신 런타임에 강제하는 타입인 `RefCell<T>`를 통해 접근 가능한 `Ref<T>`와 `RefMut<T>`

## Box<T>를 사용하여 힙에있는 데이터 가리키기

- Box는 스택이 아니라 힙에 데이터를 저장할 수 있도록 해준다. 이 점 외에는 성능에서의 오버헤드가 없음. 자주 쓰이는 케이스는 아래와 같다:
  - 컴파일 타임에 정확한 크기를 알 수 없지만, 정확한 크기를 요구하는 컨텍스트 내에서 그 타입의 값을 사용하고 싶을 때
  - 커다란 데이터를 갖고있고, 소유권을 옮기고싶지만 그렇게 했을때 데이터가 복사되지 않을것을 보장하고 싶을 때
  - 어떤 값을 소유하고 이 값의 구체화된 타입보다는 특정 trait을 구현한 타입이라는 점만 신경쓰고 싶을 때

## Box로 재귀적 타입 가능하게 하기

- 재귀적 타입(recursive type)의 값은, 자신 안에 동일한 타입의 또다른 값을 담을 수 있음.
- 러스트는 컴파일 타임에 어떤 타입이 얼만큼의 공간을 차지하는지 알아야하므로, 재귀적 타입은 문제를 일으키지만 Box는 알려진 크기를 갖고있으므로 재귀적 타입의 정의에 Box를 집어넣어서 재귀적 타입을 가능하게 할 수 있음.
  - [링크](https://github-production-user-asset-6210df.s3.amazonaws.com/61453718/331862299-5d64cdfc-c248-49df-9b7d-f2ba07587729.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20240519%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240519T095135Z&X-Amz-Expires=300&X-Amz-Signature=d404ae1632cd9d2176929136a1bd603703c4eed3fab95a981aef13abc292d585&X-Amz-SignedHeaders=host&actor_id=61453718&key_id=0&repo_id=633763124) 참고
- 그리하여, 컴파일러는 에러와 함께 아래와 같은 제안을 제공함. 여기서 간접이란, 값을 직접 저장하는 대신 데이터 구조를 바꿔 값을 가리키는 포인터를 저장하는 식으로, 값을 간접적으로 저장해야 함을 의미함.

```bash
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

- 이제 **포인터**를 가리키게 되므로, 러스트는 `Box<T>`가 필요로 하는 공간이 얼마인지 알고있다. 포인터의 크기는 데이터의 양에 따라 변경되지 않는다.

- [링크](https://github-production-user-asset-6210df.s3.amazonaws.com/61453718/331862580-3821e2b9-98df-4864-862d-6dd8e64b7283.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20240519%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240519T095558Z&X-Amz-Expires=300&X-Amz-Signature=134eb3fe698bb39a15cc9a71268204af4eb8b0d322e685dc207f914eea1ee778&X-Amz-SignedHeaders=host&actor_id=61453718&key_id=0&repo_id=633763124) 참고

- 이제 `Cons`가 `Box`를 들고 있으므로, 무한한 크기게 아니게 되었음.

- `Box<T>` 타입은, `Deref` 트레이트를 구현하고 있으므로 스마트 포인터이며, 이는 `Box<T>` 값이 참조자와 같이 취급되도록 허용해준다. 이 값이 스코프에서 벗어날 때 박스가 가리키고 있는 힙 데이터도 똑같이 정리되는데, 이는 `Drop` 트레이트의 구현때문에 그렇다.

## `Deref` 포인터로 스마트 포인터를 보통의 참조자처럼 취급하기

- `Deref` 트레이트를 구현하면, 역참조 연산자 `*` 동작의 커스터마이징을 가능하게 해줌.

## 역참조 강제

- 역참조 강제(deref coercion)란, `Deref`를 구현한 어떤 타입의 참조자를 다른 타입의 참조자로 바꿔준다.
- 예를들어, 역참조 강제는 `&String`을 `&str`로 바꿔줄 수 있다: 이는 `String`의 `Deref` 트레이트 구현이 그렇게 `&str`을 반환하도록 했기 때문.
- `Deref` 트레이트를 구현한 타입에 대해서만 적용됨.
- 어떤 특정한 타입값에 대한 참조자를 "함수 혹은 메소드의 인수"로 전달하는데, 이 함수나 메소드의 정의에는 그 매개변수 타입이 맞지 않을 때 자동으로 발생.
- 역참조 강제는, 함수와 메소드 호출을 작성하는 프로그래머들이 `&`와 `*`를 사용하여 수많은 명시적인 참조 및 역참조를 추가할 필요가 없도록 하기 위해 도입되었음.
- 또한, 이를 통해 참조자나 스마트 포인터 둘 중 어느 경우라도 작동되는 코드를 더 많이 작성할 수 있도록 해줌.

- 인수로 넣어진 타입에 대해 `Deref` 트레이트가 정의되어 있다면, 러스트는 해당 타입을 분석하고 `Deref::deref`를 필요한 만큼 사용하여 파라미터 타입과 일치하는 참조자를 얻을 것임.
- `Deref::deref`가 추가되어야 하는 횟수는 컴파일 타임에 분석되므로, 역참조 강제의 이점을 얻는 데에 관해서 어떠한 런타임 페널티도 없다.

## 역참조 강제가 가변성과 상호작용하는 방법

- `Deref` 트레이트를 사용하여 불변 참조자에 대한 `*`를 오버라이딩하는 방법과 비슷한 방식으로, `DerefMut` 트레이트를 사용하여 가변 참조자에 대한 `*` 연산자를 오버라이딩할 수 있음.
- 러스트에서는 다음의 세 가지 경우에 해당하는 타입과 트레이트 구현을 찾았을 때 역참조 강제를 수행함:
  - `T: Deref<Target=U>`일 때 `&T`에서 `&U`로
  - `T: DerefMut<Target=U>`일 때 `&mut T`에서 `&mut U`로
  - `T: Deref<Target=U>`일 때 `&mut T`에서 `&U`로
- 처음 두가지경우는 두번째가 가변성을 구현했다는 점을 제외하면 동일하다.
  - 첫번째 경우는 어떤 `&T`가 있는데 `T`가 어떤 타입 `U`에 대한 `Deref`를 구현했다면 명료하게 `&U`를 얻을 수 있음을 기술하고 있음.
  - 두번째 경우는 동일한 역참조 강제가 가변 참조자에 대해서도 발생함을 기술함.
- 세번째 경우는 좀 더 까다롭다. 러스트는 가변 참조자를 불변 참조자로 강제할 수도 있지만, **역은 불가능하다**. 불변 참조자는 가변 참조자로 결코 강제되지 않는다. 대여 규칙에 의거하여, 가변 참조자가 있을 경우에는 그 가변 참조자가 해당 데이터에 대한 유일한 참조자여야 한다.
- 불변 참조자를 가변 참조자로 변경하는 것은, 초기 불변 참조자가 해당 데이터에 대한 단 하나의 불변 참조자임을 요구할 것인데, 대여 규칙으로는 이를 보장할 수 없기에 러스트는 불변 참조자의 가변 참조자로의 변경 가능성을 가정할 수 없다.

## Drop 트레이트로 메모리 정리 코드 실행하기

- 스마트 포인터에서 중요한 트레이트 두번째는 `Drop`인데, 이는 어떤 값이 스코프 밖으로 벗어나려고 할 때 무슨 일을 할지에 대해 커스터마이징할 수 있게 해준다.
- 어떤 타입이든 `Drop`을 구현할 수 있고, 이 코드가 파일이나 네트워크 연결 같은 자원 해제에 사용되게 할 수 있다.
- 스마트 포인터의 맥락에서 `Drop`을 소개하는 이유는, `Drop` 트레이트의 기능이 스마트 포인터를 구현할 때 거의 항상 이용되기 때문이다.
  - 예를 들어 `Box<T>`가 버려질 때는, 이 Box가 가리키고 있는 힙 공간의 할당을 해제하는 것.
- 몇몇 언어들에서는 어떤 타입의 인스턴스 사용을 끝낼때마다 직접 프로그래머가 메모리, 자원을 해제하는 코드를 호출해줘야 되고 그렇지 않으면 시스템이 과부하게 걸리거나 멈출 수도 있다. 러스트에서는 값이 스코프 밖으로 벗어날 때마다 실행되는 특정 코드를 지정할 수 있고, 컴파일러가 이 코드를 자동으로 삽입해 준다. 결과적으로 프로그램 내에서 특정 인스턴스 사용이 끝나는 지점마다 메모리 정리 코드를 집어넣는 것에 관한 걱정은 하지 않아도 된다. 자원 누수는 발생하지 않는다.
- `Drop` 트레이트를 통해, 어떤 값이 스코프 밖으로 벗어났을 때 실행되는 코드를 지정한다.
- `Drop` 트레이트는 `drop`이라는 이름의 메소드를 하나 구현해야 하는데, 이 메소드는 `self`에 대한 가변 참조자를 파라미터로 갖는다.

## `std::mem::drop`으로 값을 일찍 버리기

- `drop` 비활성화는 보통 필요가 없다: `Drop` 트레이트의 요점은, 이것이 자동으로 이뤄진다는 것이기 때문이다.
- 그러나 가끔 값을 일찍 정리하고 싶을 때도 있다:
  - lock을 관리하는 스마트 포인터를 이용할 때: 강제로 `drop` 메소드를 실행하여 락을 해제해서, 같은 스코프의 다른 코드에서 해당 lock을 얻도록 하고 싶을 수도 있다.
- 러스트는 수동으로 `Drop` 트레이트의 `drop` 메소드를 호출하게 해주지는 않는 대신, 표준 라이브러리가 제공하는 `std::mem::drop` 함수를 호출하여 스코프가 끝나기 전에 강제로 값을 버리도록 할 수 있다.

## `Rc<T>`, 참조 카운트 스마트 포인터

- 대부분의 경우에서 소유권은 명확하지만, 하나의 값이 여러 개의 소유자를 가질 수 있는 경우도 있다:
  - ex) 그래프 데이터 구조에서 여러 edge가 동일한 node를 가리킬 수도 있고,
  - 그 node는 개념적으로 해당 node를 가리키는 모든 edge에 의해 소유된다.
  - 여기서 node는, **어떠한 edge도 이를 가리키지 않아 소유자가 하나도 없는 상태**가 아니라면 메모리 정리가 되어서는 안 됨.
- 명시적으로 복수 소유권을 가능하게 하려면 러스트의 `Rc<T>` 타입을 이용해야 함. 이는 참조 카운팅(reference counting)의 약자이다.
  - `Rc<T>` 타입은, 어떤 값의 참조자 개수를 계속 추적하여 해당 값이 계속 사용 중인지를 판단한다:
    - 만일 어떤 값에 대한 참조자가 0개라면 이 값의 메모리 정리를 하더라도, 유효하지 않은 참조자가 발생하지 않을 수 있다. -> 왜 "않을 수 있다"일까? 무조건 아닌 게 아닌가?
  - `Rc<T>` 타입은 프로그램의 여러 부분에서 읽을 데이터를 힙에 할당하고 싶은데 컴파일 타임에는 어떤 부분이 그 데이터를 마지막에 이용하게 될지 알 수 없는 경우 사용된다. 만일 어떤 부분이 마지막으로 사용되는지 알았다면, 그냥 그 해당 부분을 데이터의 소유자로 만들면 되고 보통의 소유권 규칙이 컴파일 타임에 수행되어 효력을 발생시킬 것이다.
  - 참조: `Rc<T>`는 오직 싱글 스레드 시나리오 용이다.
- [링크](https://github-production-user-asset-6210df.s3.amazonaws.com/61453718/331867408-d1760f15-4b21-4119-a42d-428ebc3d09b6.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20240519%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240519T112251Z&X-Amz-Expires=300&X-Amz-Signature=5fbae23581bd4231a28350899877df979240b618fe548ef7514bae531b65eb6d&X-Amz-SignedHeaders=host&actor_id=61453718&key_id=0&repo_id=633763124) 참고

## `Rc<T>`를 클론하는 것은 참조 카운트를 증가시킨다.

```rs
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

내부 스코프가 `c`를 감싸도록 하면, `c`가 스코프 밖으로 벗어날 때 참조 카운트가 어떻게 바뀌는지 볼 수 있다(`strong_count`인 이유는, `weak_count`도 있기 때문).

```bash
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

- `a`의 `Rc<List>`는 초기 참조 카운트 1을 갖고 있음을 볼 수 있다. 이후 `clone`을 호출할 때마다 카운트가 1씩 증가한다. `c`가 스코프 밖으로 벗어난 후에는 1이 감소한다. 참조 카운트를 감소시키기 위해 어떤 함수를 호출할 필요는 없다: `Rc<T>` 값이 스코프 밖으로 벗어나면, `Drop` 트레이트의 구현체가 자동으로 참조 카운트를 감소시킨다.
- `main`의 끝부분에서 `b`와 그다음 `a`가 스코프 밖으로 벗어나서 카운트가 0이되고 그시점에서 `Rc<List>`가 완전히 메모리 정리되는 것은 이 예제에서 볼 수가 없다: `Rc<T>`를 이용하면 단일 값이 복수 소유자를 갖도록 할 수 있고, 그 개수는 소유자 중 누구라도 계속 존재하는 한 해당 값이 계속 유효하도록 보장해 준다.

- `Rc<T>`는 불변 참조자를 통해 읽기 전용으로 프로그램의 여러 부분에서 데이터를 공유하도록 해준다. 만일 `Rc<T>`가 여러 개의 가변 참조자도 만들도록 해준다면, 대여 규칙 중 하나를 위반할지도 모른다: 동일한 위치에서 여러 개의 가변 대여는 데이터 경합 및 불일치를 야기할 수 있다.

## 순환 참조는 메모리 누수를 발생시킬 수 있습니다

- 러스트의 메모리 안정성 모장은 뜻하지 않게 해제되는 메모리(메모리 누수: memory leak)를 생성하기 어렵게 만들지만, 불가능하게 만드는 것은 아님.
- `Rc<T>`와 `RefCell<T>`를 사용하면, 러스트에서 메모리 누수가 허용되는 것을 알 수 있다: 즉 아이템들이 서로를 순환 참조하는 참조자를 만드는 것이 가능하다. -> 이는 메모리 누수를 발생시키는데, 그 이유는 순환 고리 안의 각 아이템의 참조 카운트가 결코 0이 되지 않을 것이고, 따라서 그 값들은 버려지지 않을 것이기 때문이다.

[링크](https://github-production-user-asset-6210df.s3.amazonaws.com/61453718/331876987-9d44031f-16d7-4b75-b9ab-0f12771b3d9c.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20240519%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20240519T140136Z&X-Amz-Expires=300&X-Amz-Signature=f39772a39224569a39ceb11383cd69e529f0ddac784ef53c4dbbd9b8f8ba92a6&X-Amz-SignedHeaders=host&actor_id=61453718&key_id=0&repo_id=633763124) 참고

- `Rc<T>` 값을 갖고있는 `RefCell<T>` 혹은, 그와 유사하게 내부 가변성 및 참조 카운팅 기능이 있는 타입들의 중첩된 조합을 사용한다면, 사용자가 직접 순환을 만들지 않음을 보장해야 한다.
- 순환 참조를 만드는것은 프로그램의 논리적 버그로서, 자동화된 테스트, 코드리뷰, 그외 소프트웨어 개발연습등을 통해 최소화해야 한다.

## 순환 참조 방지: `Rc<T>`를 `Weak<T>`로 바꾸기

- 지금까지는 `Rc::clone`을 호출하는 것이 `Rc<T>` 인스턴스의 `strong_count`를 증가시키고 `Rc<T>` 인스턴스는 자신의 `strong_count`가 0이 된 경우에만 제거하는 것을 봤다.
- `Rc::downgrade`에 `Rc<T>`의 참조자를 넣어서 호출하면 `Rc<T>` 인스턴스 내의 값을 가리키는 약한 참조를 만드는 것도 가능하다.
  - 강한 참조: `Rc<T>` 인스턴스의 소유권 공유
  - 약한 참조: 소유권 관계를 표현하지 않고, 약한참조의 개수는 `Rc<T>` 인스턴스가 제거되는 경우에 영향을 주지 않는다.
    - 약한 참조가 포함된 순환 참조는 그값의 강한 참조 개수를 0으로 만드는 순간 깨지므로 순환 참조를 일으키지 않게 될 것이다.
- `Rc::downgrade`를 호출하면 `Weak<T>` 스마트 포인터를 얻게된다:
  - `Rc::downgrade`는 `Rc<T>` 인스턴스의 `strong_count`를 1 증가시키는대신 `weak_count`를 1 증가시킨다.
  - `Rc<T>` 타입은 `strong_count`와 유사한 방식으로 `weak_count`를 사용하여 `Weak<T>` 참조가 몇개있는지 추적한다.
  - 차이점으로는, `Rc<T>` 인스턴스가 제거되기 위해 `weak_count`가 0일 필요는 없다는 것.
- `Weak<T>`가 참조하는 값이 버려졌을지도 모르기때문에 `Weak<T>`가 가리키고있는 값으로 어떤 일을 하기 위해서는 그값이 여전히 존재하는지 반드시 확인해야한다. 이를위해 `Weak<T>`의 `upgrade` 메소드를 호출하는데, 이는 `Option<Rc<T>>`를 반환할 것이다.
  - 만일 `Rc<T>` 값이 아직 버려지지 않앗다면 `Some` 결과를 얻게될것이고 `Rc<T>` 값이 버려졌다면 `None` 결과를 얻게될것이다.
  - 이 경우 `Option<T>`를 반환하므로 `Some`의 경우와 `None`의 경우가 모두 처리되어, 유효하지 않은 포인터는 없을것이다.

## 트리 데이터 구조 만들기: 자식 노드를 가진 `Node`.

## 일반적인 컬렉션

- 대부분의 다른 데이터 타입은 단일한 특정 값을 나타내지만, 컬렉션은 다수의 값을 담을 수 있다. 내장된 배열(build-in array)이나 튜플 타입과는 달리, 이 컬렉션들이 가리키고 있는 데이터들은 힙에 저장되는데 이는 즉 데이터의 양이 컴파일 타임에 결정되지 않아도 되며 프로그램 실행 중에 늘어나거나 줄어들 수 있다는 의미이다
- 컬렉션 중 자주 사용되는 3가지는 다음과 같다.

1. 벡터(Vector): 여러 개의 값을 서로 붙어 있게 저장할 수 있도록 해준다.
2. 문자열(String): 문자(character)의 모음이다.
3. 해시맵(HashMap): 어떤 값을 특정한 키와 연관지어 주도록 해준다. 맵(map)이라 일컫는 좀 더 일반적인 데이터 구조의 특정한 구현 형태이다.

### 벡터에 여러 값의 목록 저장하기

- 벡터는 `Vec<T>`의 형태로 사용한다. 벡터를 사용하면 메모리에서 모든 값을 서로 이웃하도록 배치하는 단일 데이터 구조에 하나 이상의 값을 저장할 수 있다.
- 벡터는 같은 타입의 값만을 저장할 수 있다.

#### 새 벡터 만들기

```rs
    let v: Vec<i32> = Vec::new();
```

- 이 벡터에 어떠한 값도 넣지 않았기 때문에, 러스트는 저장하고자 하는 요소가 어떤 타입인지 모른다. 특정한 타입의 값을 저장할 벡터를 만들 때는 꺾쇠괄호(`<>`) 안에 해당 타입을 지정한다.
- Rust는 편의를 위해 `vec!` 매크로를 제공하는데, 이 매크로는 제공된 값들을 저장한 새로운 `Vec`을 생성한다. 아래의 `v`는, `1`,`2`,`3`을 저장한 새로운 `Vec<i32>`을 생성한다.

```rs
let v = vec![1, 2, 3];
```

#### 벡터 업데이트하기

```rs
let mut v = Vec![1, 2, 3];

// 당연하지만, push를 하려면 v는 mutable해야한다(let mut v여야 가능).
v.push(5);
v.push(6);
v.push(7);
v.push(9);
```

#### 벡터 요소 읽기

크게 인덱싱과 `get` 메소드가 있다.

```rs
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
let third2: Option<&i32> = v.get(2);

let does_not_exist = &v[100]; // 패닉을 일으킴.
let does_not_exist = v.get(100); // `None`을 반환함.
```

벡터는 모든 요소가 서로 붙어서 메모리에 저장된다. 그리고 새로운 요소를 벡터 끝에 추가할 경우, 현재 벡터 메모리 위치에 새로운 요소를 추가할 공간이 없다면 다른 넉넉한 곳에 메모리를 새로 할당하고 기존 요소를 새로 할당한 공간에 복사한다. 이 경우 기존 요소의 참조자는 해제된 메모리를 가리키게 되기 때문에, 이러한 상황을 대여 규칙으로 막아두었다.

#### 열거형을 이용해 여러 타입 저장하기

벡터는 같은 타입을 가진 값들만 저장할 수 있다. 다른 값들을 가진 타입을 저장하려면 이넘을 사용해야 한다.

```rs
enum SpreadsheetCell {
    Int(i32),
    Float(i64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Float(10.12),
    SpreadsheetCell::Text(String::from("blue")),
]
```

Rust가 컴파일 타임에 벡터 내에 저장될 타입이 무엇인지 알아야 하는 이유는, 각 요소를 저장하기 위해 얼마만큼의 힙 메모리가 필요한지를 알아야 하기 때문이다. 또한 이 벡터가 담을 수 있는 타입을 명시적으로 보여줘야 한다. 만약 Rust가 어떤 타입이든 담을 수 있는 벡터를 허용한다면, 벡터의 각 요소마다 수행되는 연산에 대해 하나 혹은 그 이상의 타입이 에러를 발생시킬 수도 있다. enum과 `match` 표현식을 사용한다는 것은, Rust가 컴파일 타임에 가능한 모든 경우를 처리함을 보장해 준다는 뜻이다.

#### 벡터가 버려지면 벡터의 요소도 버려진다.

`struct`와 마찬가지로 벡터는 스코프를 벗어날 때 해제된다(즉, 벡터가 갖고 있던 정수들의 메모리도 정리된다).

```rs
{
    let v = vec![1, 2, 3, 4, 5];
    // v를 사용한 작업..
} // v가 스코프 밖으로 벗어나고, 해제된다.
```

### String

갓 입문한 러스트 사용자는 3가지 이유의 조합에 의해 문자열 부분에서 막힌다.

```
1. 발생할 수 있는 에러를 최대한 표시하는 Rust의 성향
2. 많은 프로그래머의 예상보다 문자열이 복잡한 구조라는 점
3. `UTF-8`
```

문자열이 바이트의 컬렉션으로 구현되어 있고, 이 바이트들을 텍스트로 통역할 때 유용한 기능을 제공하는 여러 메소드들을 구현해 두었기 때문에, 문자열은 컬렉션의 장에 속한다.

#### 문자열이란?

- Rust 언어의 핵심 기능에서는 딱 한 가지 문자열 타입만 제공하는데, 이는 바로 참조자 형태인 `&str`로 많이 봤던 문자열 슬라이스 `str`이다.
- `String` 타입은, Rust의 표준 라이브러리를 통해 제공되며, 커질 수 있고, 가변적이며, 소유권을 갖고 있고, `UTF-8`로 인코딩된 문자열 타입이다.
- 보통 Rust에서 '문자열'에 대해 얘기할 때는 `String`과 문자열 슬라이스 `&str` 둘 중 무언가를 얘기하는 것이지, 특정한 하나를 얘기하는 것은 아니다.

#### 새로운 문자열 생성

`Vec<T>`에서 쓸 수 있는 연산 다수가 `String`에서도 똑같이 쓸 수 있는데, 이는 `String`이 실제로 바이트 벡터에 더하여 몇 가지 보장, 제한, 기능들을 추가한 래퍼로 구현되어있기 때문이다.

```rs
let mut s = String::new();
```

`String::from`과 `to_string`은 동일한 작업을 수행하므로, 어떤 것을 사용하는가는 스타일과 가독성의 문제이다.

#### 문자열 업데이트

`String`은 `Vec`의 내용물처럼, 더 많은 데이터를 집어넣으면 크기가 커지고 내용물은 변경될 수 있다. 또한 `+` 연산자나 `format!` 매크로를 사용하여 편리하게 `String` 값들을 이어붙일 수 있다.

```rs
let mut s = String::from("foo");
s.push_str("bar");
```

위의 두 줄이 실행된 이후 `s`에는 `foobar`가 들어있을 것이다. `push_str` 메소드는, 문자열 슬라이스를 파라미터로 갖는데 이는 파라미터의 소유권을 가져올 필요가 없기 때문이다.

반대로 `+` 연산자를 사용할 경우 소유권이 이전된다. `+` 연산자는 `add` 메소드를 사용하는데, 이 메소드의 시그니처는 아래와 같다:

```rs
fn add(self, s+ &str) -> String {
    // ...
}
```

정확히는, 첫번째 문자열에 두번째 문자열의 **참조자**를 더하고 있음을 뜻한다. 이는 `add` 함수의 `s` 파라미터 때문이다: `String`에는 `&str`만 더할 수 있고, 두 `String` 끼리는 더하지 못한다. 헌데, `String` 타입에 `&String` 타입을 더하는 경우라고 하더라도 문제없이 컴파일이 된다. 그 이유는, `&String` 인수가 `&str`로 강제될 수 있기 때문이다.

`add` 함수가 호출되면 Rust는 역참조 강제(`deref coercion`)를 사용하는데, 이것이 `add` 함수 내에서 사용되는 `&s2`를 `&s2[..]`로 변경한다. `add`가 매개변수의 소유권을 가져가지는 않으므로, `s2`는 이 연산 이후에도 계속 유효한 `String`일 것이다.

다음으로, 시그니처에서 `add`가 `self`의 소유권을 가져가는 것을 볼 수 있는데, 이는 `self`가 `&`를 갖고 있지 않기 때문이다. 따라서 `let s3 = s1 + &s2;`의 형태가 마치 두 문자열을 복사하여 새로운 문자열을 만들 것처럼 보일지라도, 실제로 이 구문은 `s1`의 소유권을 가져다가 `s2`의 내용물의 복사본을 추가한 다음, 결과물의 소유권을 반환한다. 바꿔 말하면, 이 구문은 여러 복사본을 만드는 것처럼 보이더라도 그렇지 않다: 이러한 구현은 복사보다 더 효율적이다.

여러 문자열을 접하고자 한다면 `+`의 동작은 다루기 불편해진다:

```rs
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
```

이 시점에서 `s`는 `tic-tac-toe`가 될것이다. `+`와 `"` 문자가 많으면, 어떤 결과가 나올지 확인하기가 어렵다. 더 복잡한 문자열에는 `format!` 매크로를 사용할 수 있다.

```rs
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
```

(파이썬의 `f-string`이 생각난다.)

이 코드 또한 `s`에 `tic-tac-toe`를 설정한다. `format!` 매크로는 `println!`처럼 작동하지만 화면에 결과를 출력하는 대신 결과가 담긴 `String`을 반환해 준다. `format!`을 이용한 버전이 훨씬 읽기 쉽고, `format!` 매크로로 만들어진 코드는 **참조자**를 이용하므로 이 호출은 아무 파라미터의 소유권도 가져가지 않는다.

#### 문자열 내부 인덱싱의 불가능

```rs
let s1 = String::from("hello");
let h = s1[0]; // String` cannot be indexed by `{integer}`
```

왜 Rust 문자열은 인덱싱을 지원하지 않을까? 이 질문에 대한 답을 하기 위해서는 Rust가 문자열을 메모리에 저장하는 방법에 대해 설명해야 한다.

`String`은 `Vec<u8>`을 감싼 것이다.

```rs
let hello = String::from("hola");
```

이 경우 `len`은 4가 되는데, 이는 문자열 'Hola'를 저장하고 있는 `Vec`이 4바이트 길이라는 뜻이다. UTF-8로 인코딩되면 각각의 글자들이 1바이트씩 차지한다는 것이다. 그러나 아래의 경우를 보자:

```rs
let hello = String::from("Здравствуйте");
```

이 hello String의 길이는 얼마일까? 놀랍게도 12가 아니라 24이다. 이 24는 `Здравствуйте`를 UTF-8로 인코딩한 바이트들의 크기인데, 각각의 유니코드 스칼라 값이 저장소의 2바이트를 차지하기 때문이다.

```rs
let hello = "Здравствуйте";
let answer = &hello[0];
```

이런 코드가 있다고 했을 때 `answer`가 3이 나오지 않을 것이라는 건 이미 알 것이다. UTF-8로 인코딩될 때 `3`의 첫번째 바이트는 `208`이고, 두번째 바이트는 `151`이므로 `answer`는 `208`이 되어야하지만, `208`은 그 자체로는 유효한 문자가 아니다.

따라서 예상치 못한 값(UTF-8로 인코딩된 값)을 반환하고 즉시 발견되지 않을 수 있는 버그를 방지하기 위해 Rust는 이러한 코드를 전혀 컴파일하지 않는다. 이러한 오해들은 개발 과정에서 걸러질 수 있다.

Rust가 `String`을 인덱스로 접근하여 문자를 얻지 못하도록 하는 다른 이유는, 인덱스 연산이 언제나 상수 시간(`O(1)`)에 실행될 것으로 기대받기 때문이다. 그러나 `String` 타입을 갖고 그러한 성능을 보장하는 것은 불가능한데, 그 이유는 Rust가 문자열 내에 유효한 문자가 몇 개나 있는지 알아내기 위해 내용물을 시작 지점으로부터 인덱스로 지정된 곳까지 훑어야 하기 때문이다.

#### 문자열 슬라이싱

문자열 인덱싱의 반환 타입이 어떤 것이 되어야 하는지(바이트 값인지, character인지, 문자소 클러스터인지, 문자열 슬라이스인지) 명확하지 않기 때문에 문자열의 인덱싱은 종종 좋지 않은 생각이 된다. 그래서, 문자열 슬라이스를 만들기 위해 인덱싱을 사용하려 한다면 Rust는 좀더 구체적인 지정을 요청한다.

```rs
let hello = "Здравствуйте";

let s = &hello[0..4];
```

여기서 `s`는 문자열의 첫 4바이트를 담고 있는 `&str`가 된다. 우리는 이 글자들이 각각 2바이트씩 차지한다고 언급했으므로 `s`는 `Зд`가 될 것이다. `&hello[0..1]`처럼 문자 바이트의 일부를 슬라이싱 하려고 한다면(즉, `3`이라는 최초의 문자열이 만들어지기 전 인덱스에 접근하려 한다면) Rust는 벡터 내에 유효하지 않은 인덱스에 접근했을 때와 동일한 방식으로 런타임에 패닉을 발생시킬 것이다.

범위를 지정하여 문자열 슬라이스를 생성하는 것은 프로그램을 죽게 만들 수도 있으므로 주의깊게 사용되어야 한다.

가장 좋은 방법은, 문자열에 대한 반복을 진행하는 것이다.

```rs
for c in "Зд".chars() {
    println!("{c}");
}
// З
// д

for b in "Зд".bytes() {
    println!("{b}"); // 각 문자에 대한 바이트 값을 반환한다.
}
// 208
// 151
// 208
// 180
```

#### 문자열은 그렇게 단순하지 않다

요약하면 문자열은 복잡하다. 프로그래밍 언어마다 이러한 복잡성을 프로그래머에게 표현하는 방법에 대해 다른 선택을 한다. Rust는 `String` 데이터의 올바른 처리를 모든 Rust 프로그램의 기본 동작으로 선택했는데, 이는 프로그래머가 UTF-8 데이터를 처리할 때 미리 더 많은 생각을 해야함을 의미한다. 이러한 절충안은 다른 프로그래밍 언어보다 문자열의 복잡성을 더 많이 노출시키지만, 한편으로는 ASCII가 아닌 문자와 관련된 에러를 처리해야 할 필요가 없도록 해준다.

좋은 소식이 있다면 표준 라이브러리에 이런 복잡한 상황을 올바르게 처리하는 데 도움이 될 `String` 및 `&str` 타입 기반의 기능을 다양하게 제공한다는 점이다.

- 러스트에는 코드 조직화에 필요한 기능이 여럿 있다. 어떤 세부 정보를 외부에 노출할지, 비공개로 둘지, 프로그램의 스코프 내에 어떤 이름이 있는지 등 다양하다. 이를 통틀어 **모듈 시스템**이라고 하며, 다음 기능들이 포함된다:

1. 패키지: 크레이트를 빌드하고 테스트하고 공유하는 데 사용하는 Cargo 기능
2. 크레이트: 라이브러리나 실행 가능한 모듈로 구성된 트리 구조
3. 모듈과 `use`: 구조, 스코프를 제어하고 조직 세부 경로를 감추는 데 사용
4. 경로: 구조체, 함수, 모듈 등의 이름을 지정

## 패키지와 크레이트

- 크레이트(crate)는, 러스트가 컴파일 한 차례에 고려하는 가장 작은 코드 단위이다. `cargo` 대신 `rustc`를 실행하여 단일 소스코드 파일을 넘겨주더라도, 컴파일러는 그 파일이 크레이트라고 생각한다. 크레이트는 여러 모듈을 담을 수 있고, 모듈은 이 크레이트와 함께 컴파일되는 다른 파일들에 정의되어 있을 수도 있다.
- 크레이트는 바이너리(binary)일 수도 있고, 라이브러리(library)일 수도 있다.
  - 바이너리 크레이트는, 커맨드 라인 프로그램이나 서버처럼 실행 가능한 실행파일로 컴파일할 수 있는 프로그램으로, `main` 함수를 포함하고 있어야 한다.
  - 라이브러리 크레이트는 `main` 함수를 갖고 있지 않고 실행파일 형태로 컴파일 되지는 않지만 여러 프로젝트에서 공용될 의도로 만들어진 기능들이 정의되어 있다. (자바스크립트의 라이브러리와 같은 느낌이라고 보면 될 것 같다.)
- 패키지(package)는 일련의 기능을 제공하는 하나 이상의 크레이트로 구성된 번들이다. 패키지에는 이 크레이트들을 빌드하는 법이 설명된 `Cargo.toml` 파일이 포함되어 있다.
- 패키지에는 여러 개의 바이너리 크레이트가 포함될 수 있지만, 라이브러리 크레이트는 하나만 넣을 수 있다. 최소 하나의 크레이트는 있어야 하며, 라이브러리인지 바이너리인지는 상관없다.
- `cargo new` 명령어를 사용하여 패키지를 생성하면 아래와 같은 일이 발생한다.

```
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
```

`Cargo.toml`이 패키지를 만들어 준다.

- cargo는, "바이너리 크레이트의 경우 크레이트의 루트는 `src/main.rs`"라는 관례를 준수한다.
- 마찬가지로, 패키지 디렉토리에 `src/lib.rs` 파일이 존재할 경우 cargo는 해당 패키지가 패키지명과 같은 이름의 라이브러리 크레이트를 포함하고 있다고 판단하며, 위의 루트가 크레이트 루트라고 판단한다.

## 모듈, 경로, `use`, `pub`

- 크레이트 루트부터 시작: 크레이트를 컴파일할 때 컴파일러는 먼저 크레이트 루트 파일(`src/lib.rs` 혹은 `src/main.rs`)을 본다.
- 모듈 선언: 크레이트 루트 파일에는 새로운 모듈을 선언할 수 있다; `mod garden;`이라는 코드로 `garden` 모듈을 선언할 수 있다. 컴파일러는 아래의 위치에서 이 모듈의 코드가 있는지 살펴볼 것이다.
  - `mod garden` 뒤에 세미콜론 대신 중괄호를 써서 안쪽에 코드를 적은 인라인
  - `src/garden.rs` 파일 내부
  - `src/garden/mod.rs` 파일 내부
- 서브모듈 선언: 크레이트 루트가 아닌 다른 파일에서는 서브모듈(submodule) 선언을 할 수 있다. 예를 들면 `src/garden.rs` 파일 내부에 `mod vegetables;`를 선언할 수도 있다. 컴파일러는 부모 모듈 이름의 디렉토리 안쪽에 위치한 아래의 장소들에서 이 서브모듈의 코드가 있는지 살펴볼 것이다:
  - `mod vegetables` 뒤에 세미콜론 대신 중괄호를 써서 안쪽에 코드를 적은 인라인
  - `src/garden/vegetables.rs` 파일 내부
  - `src/garden/vegetables/mod.rs` 파일 내부
- 모듈 내 코드로의 경로: 모듈이 크레이트의 일부로서 구성되면, 공개 규칙이 허용되는 한도 내에서라면 해당 코드의 경로를 사용하여 동일한 크레이트의 어디에서든 이 모듈의 코드를 참조할 수 있게 된다. 예를 들면, garden vegetables 모듈 안에 있는 `Asparagus` 타입은 `crate::garden::vegetables::Asparagus`로 찾아 쓸 수 있다.
- 비공개 vs 공개: 모듈 내의 코드는 기본적으로 부모 모듈에게 비공개(private)이다. 모듈을 공개(public)로 만들려면 `mod` 대신 `pub mod`를 써서 선언해야 한다. 공개 모듈의 아이템들을 공개하려면 마찬가지로 그 선언 앞에 `pub`를 붙이면 된다.
- `use` 키워드: 어떤 스코프 내에서 `use` 키워드는 긴 경로의 반복을 줄이기 위한 어떤 아이템으로서의 단축 경로를 만들어 준다. `crate::garden::vegetables::Asparagus`를 참조할 수 있는 모든 스코프에서 `use crate::garden::vegetables::Asparagus;`로 단축경로를 만들 수 있으며, 그 이후부터는 스코프에서 이 타입을 사용하려면 `Asparagus`만 작성해주면 된다.
